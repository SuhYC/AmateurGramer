# Redis
### Hiredis
### c++ project

### Multi-Threading
Redis는 요청을 처리하는 방식이 싱글스레드이다.   
물론 내부 로직 처리 중에 어느정도 멀티스레드를 사용하긴 하지만, 결과적으로 요청과 응답은 싱글스레드로 처리한다는 의미이다.   
Redis를 외부 시스템에서 사용한다고 가정했을 때, 소요되는 시간은   
1. 네트워크 시간
2. Redis 요청 수용 로직
3. DB처리 로직 (물론 보조기억장치가 아닌 주기억장치에서 처리한다.)
4. Redis 응답 로직
5. 네트워크 시간
순으로 처리된다.

이 때, 2~4의 과정은 싱글스레드로 요청순서대로 처리한다고 가정하더라도, 1과 5의 네트워크 시간이 존재하며,   
꼭 Redis 요청 말고도 기본적으로 멀티스레드 환경에서 lock을 걸고 1개의 RedisContext를 통해 통신하는 것은 비효율적이라고 생각해 멀티스레드환경을 구성하여 테스트하였다.   
(당연히 하나의 RedisContext로 통신하는 경우 상호배제가 필요하다.)   
조건은 다음과 같다.   
N개의 RedisContext과 mutex를 할당받아둔다.   
M개의 Thread가 mutex를 try_lock으로 조회하여 상호배제하며, n개의 뮤텍스 모두 lock을 획득할 수 없으면 다른 스레드로 양보한다.   
각각의 스레드는 1번의 SETEX연산을, 1000번의 GET 연산을 요청한다.

N == 1, M == 10일 때 정해진 동작을 수행하는데 1900ms 정도가 걸렸고,   
N == 5, M == 10일 때 정해진 동작을 수행하는데 500ms 정도가 걸렸고,   
N == 8, M == 10일 때 정해진 동작을 수행하는데 360ms 정도가 걸렸고,   
N == 10, M == 10일 때 정해진 동작을 수행하는데 320ms 정도가 걸렸다.

다수의 RedisContext를 할당해 처리하는 방식이 효과적이었다.
