# Redis
### Hiredis
### c++ project

### Multi-Threading
Redis는 요청을 처리하는 방식이 싱글스레드이다.   
물론 내부 로직 처리 중에 어느정도 멀티스레드를 사용하긴 하지만, 결과적으로 요청과 응답은 싱글스레드로 처리한다는 의미이다.   
Redis를 외부 시스템에서 사용한다고 가정했을 때, 소요되는 시간은   
1. 네트워크 시간
2. Redis 요청 수용 로직
3. DB처리 로직 (물론 보조기억장치가 아닌 주기억장치에서 처리한다.)
4. Redis 응답 로직
5. 네트워크 시간
순으로 처리된다.

이 때, 2~4의 과정은 싱글스레드로 요청순서대로 처리한다고 가정하더라도, 1과 5의 네트워크 시간이 존재하며,   
꼭 Redis 요청 말고도 기본적으로 멀티스레드 환경에서 lock을 걸고 1개의 RedisContext를 통해 통신하는 것은 비효율적이라고 생각해 멀티스레드환경을 구성하여 테스트하였다.   
(당연히 하나의 RedisContext로 통신하는 경우 상호배제가 필요하다.)   
조건은 다음과 같다.   
N개의 RedisContext과 mutex를 할당받아둔다.   
M개의 Thread가 mutex를 try_lock으로 조회하여 상호배제하며, n개의 뮤텍스 모두 lock을 획득할 수 없으면 다른 스레드로 양보한다.   
각각의 스레드는 1번의 SETEX연산을, 1000번의 GET 연산을 요청한다.

N == 1, M == 10일 때 정해진 동작을 수행하는데 1900ms 정도가 걸렸고,   
N == 5, M == 10일 때 정해진 동작을 수행하는데 500ms 정도가 걸렸고,   
N == 8, M == 10일 때 정해진 동작을 수행하는데 360ms 정도가 걸렸고,   
N == 10, M == 10일 때 정해진 동작을 수행하는데 320ms 정도가 걸렸다.

다수의 RedisContext를 할당해 처리하는 방식이 효과적이었다.

---------------------------------------------------

#### 그렇다면 스레드마다 RedisContext를 할당하고, 연결을 시도하며 대신 lock을 걸지 않으면 얼마나 걸릴까?

동일하게 10개의 스레드가 각각 1번의 연결을, 1번의 SETEX연산을, 1000번의 GET연산을 요청하도록 구성하여 테스트했다.
(N은 의미 없음. mutex를 사용하는 것이 아니기 때문)   
M == 10일 때 정해진 동작을 수행하는데 300ms 정도가 걸렸다.

#### 추가로 요청마다 연결하는 방식은 어떨까?

동일하게 10개의 스레드가 이번에는   
SETEX연산 1회마다 연결 - 요청 - 해제   
GET연산 1회마다 연결 - 요청 - 해제   
와 같은 형태로 10개의 스레드, 1번의 SETEX, 1000번의 GET을 요청하도록 구성하여 테스트했다 (연결요청만 합해서 10010번..)   
M == 10일 때 정해진 동작을 수행하는데 4800ms 정도가 걸렸다.

## 결론

스레드마다 Context를 할당하여 다수의 Context를 사용하는 것은 redis 사용에 들어가는 오버헤드를 줄이는데 도움이 된다.   
하지만 lock을 사용하는 것은 상호배제를 위한 오버헤드가 조금 들어가게 되며   
요청마다 Context를 할당하는 것은 통신 오버헤드가 더 많이 추가되어 1개의 mutex로 상호배제한 것보다 더 치명적인 시간소모가 발생한다.

즉, redis와 통신할 스레드 들에 redis 연결시도를 1회 작성해 둔 후,   
유저요청큐에서 요청목록을 받아와 처리하는 것을 반복하고,   
서버가 종료될 때 redis연결 종료 후 서버를 닫을 수 있게 작성하는 것이 위 방법들 중 가장 시간자원을 효율적으로 사용하는 방법이 되겠다.

    void work()
    {
      redisContext* conn = redisConnect(ip, port); // 서버 가동당 1회!

      ~~

      while(isRun)
      {
        ~~
      }

      redisFree(conn); // 마무리는 확실하게!

      return;
    }
